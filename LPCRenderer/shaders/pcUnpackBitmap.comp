#version 450 core
#extension GL_ARB_shader_atomic_counter_ops : require

layout(std430, binding = 0) restrict readonly buffer coherent InputBuffer
{
	uint bitmaps[];
};

layout(std430, binding = 1) restrict writeonly buffer coherent OutputBuffer
{
	uint positions[];
};

struct DrawCommand
{
	uint count;
	uint instanceCount;
	uint first;
	uint baseInstance;
};

layout(std430, binding = 2) restrict buffer coherent DrawBuffer
{
	DrawCommand commands[];
};

layout(binding = 0) uniform atomic_uint currentPositionsCount;

const uint bitmapSize = 256;//[32,256] Bits per side
//keep local_size_x = 1 for better cache coherency
layout (local_size_x = 1, local_size_y = bitmapSize, local_size_z = 1024 / bitmapSize ) in;

const uint bitmapRowSize = bitmapSize / 32;//uints per row

const uint workGroupIndex = gl_WorkGroupID.x;
const uint brickReadStart = gl_WorkGroupID.x * bitmapSize * bitmapSize * bitmapRowSize;
shared uint brickWriteOffset;
shared uint brickWriteStart;
const uvec3 localBitCount = bitmapSize / gl_WorkGroupSize;
uint localPositionCount = 0;
void main()
{
	//we need to reserve space for the work group in the positions buffer
	if(gl_LocalInvocationIndex == 0)
	{	
		commands[workGroupIndex].first = atomicCounterAddARB(currentPositionsCount, commands[workGroupIndex].count);
		atomicExchange(brickWriteStart, commands[workGroupIndex].first);
		atomicExchange(brickWriteOffset, 0);
	}

	memoryBarrierShared();
	barrier();

	//push points to appropriate place in buffer
	for(uint z = gl_LocalInvocationID.y * localBitCount.y; z < (gl_LocalInvocationID.y + 1) * localBitCount.y; z++)
	{
		for(uint y = gl_LocalInvocationID.z * localBitCount.z; y < (gl_LocalInvocationID.z + 1) * localBitCount.z; y++)
		{
			for(uint x = gl_LocalInvocationID.x * (localBitCount.x / 32); x < (gl_LocalInvocationID.x + 1) * (localBitCount.x / 32); x++)
			{
				uint idx = brickReadStart + z * bitmapSize * bitmapRowSize + y * bitmapRowSize + x;
				for(uint bit = 0; bit < 32; bit++)
				{
					if((bitmaps[idx] & (1 << bit)) != 0)
					{
						vec3 position = vec3(x * 32 + bit, y, z) / bitmapSize;
						uint offset = atomicAdd(brickWriteOffset, 1);

						positions[brickWriteStart + offset] = packUnorm4x8(position.xyzz);
					}
				}
			}
		}
	}
}