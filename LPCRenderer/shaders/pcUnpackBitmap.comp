#version 450 core

layout(std430, binding = 0) buffer BitmapsBuffer
{
	uint bitmaps[];
};

struct DrawCommand
{
	uint count;
	uint instanceCount;
	uint first;
	uint baseInstance;
};

//layout(std430, binding = 1) buffer DrawBuffer
//{
//	DrawCommand commands[];
//};

layout(std430, binding = 2) buffer PositionsBuffer
{
	uint positions[];
};

layout(binding = 0) uniform atomic_uint currentPositionsCount;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

shared uint brickPointCount;
void main()
{
	if(gl_LocalInvocationIndex == 0)
	{
		atomicExchange(brickPointCount, 0);
	}

	memoryBarrierShared();
	uint bitmapIndex = 0;
	//count number of points in current brick
	for(uint z = gl_LocalInvocationID.z * 32; z < (gl_LocalInvocationID.z + 1) * 32; z++)
	{
		for(uint y = gl_LocalInvocationID.y * 32; y < (gl_LocalInvocationID.y + 1) * 32; y++)
		{
			uint idx = bitmapIndex * 256 * 256 * 8;
			idx += z * 256 * 8;
			idx += y * 8;
			idx += gl_LocalInvocationID.x;
			atomicAdd(brickPointCount, bitCount(bitmaps[idx]));
		}
	}
	barrier();

	//now we need to reserves space in the positions buffer
	if(gl_LocalInvocationIndex == 0)
	{
		uint workGroupIndex = gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;
		workGroupIndex += gl_WorkGroupID.y * gl_NumWorkGroups.x;
		workGroupIndex += gl_WorkGroupID.x;
//		commands[workGroupIndex].instanceCount = 0;
//		commands[workGroupIndex].baseInstance= 0;
//		commands[workGroupIndex].first = 0;
//		commands[workGroupIndex].count = brickPointCount;

	}
	barrier();

	//push points to appropriate place in buffer
	for(uint z = gl_LocalInvocationID.z * 32; z < (gl_LocalInvocationID.z + 1) * 32; z++)
	{
		for(uint y = gl_LocalInvocationID.y * 32; y < (gl_LocalInvocationID.y + 1) * 32; y++)
		{
			uint idx = bitmapIndex * 256 * 256 * 8;
			idx += z * 256 * 8;
			idx += y * 8;
			idx += gl_LocalInvocationID.x;
			uint bytes = bitmaps[idx];
			for(uint bit = 0; bit < 32; bit++)
			{
				bool occupied = (bytes & (1 << bit)) != 0;
				if(occupied)
				{
					vec3 position = vec3(gl_LocalInvocationID.x * 32 + bit, y, z) / 256.0f;
					positions[atomicCounterIncrement(currentPositionsCount)] = packUnorm4x8(position.xyzz);
				}
			}
		}
	}
}