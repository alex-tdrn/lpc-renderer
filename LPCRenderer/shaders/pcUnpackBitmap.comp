#version 450 core
#extension GL_ARB_shader_atomic_counter_ops : require

layout(std430, binding = 0) restrict buffer BitmapsBuffer
{
	uint bitmaps[];
};

layout(std430, binding = 1) restrict buffer PositionsBuffer
{
	uint positions[];
};

struct DrawCommand
{
	uint count;
	uint instanceCount;
	uint first;
	uint baseInstance;
};

layout(std430, binding = 2) restrict buffer DrawBuffer
{
	DrawCommand commands[];
};

layout(binding = 0) uniform atomic_uint currentPositionsCount;

layout (local_size_x = 1, local_size_y = 8, local_size_z = 64) in;

shared uint brickWriteOffset;
const uint workGroupIndex = gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y + gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
const uint bitmapIndex = gl_WorkGroupID.x;
const uvec3 localBitCount = 256 / gl_WorkGroupSize;
uint localPositionCount = 0;
void main()
{
	//we need to reserves space in the positions buffer
	if(gl_LocalInvocationIndex == 0)
	{	
		commands[workGroupIndex].first = atomicCounterAddARB(currentPositionsCount, commands[workGroupIndex].count);
		atomicExchange(brickWriteOffset, 0);
	}
	memoryBarrierShared();
	barrier();

	//count the number of positions in local invocation, to reduce memory barriers for 'brickWriteOffset' 
	for(uint z = gl_LocalInvocationID.z * localBitCount.z; z < (gl_LocalInvocationID.z + 1) * localBitCount.z; z++)
	{
		for(uint y = gl_LocalInvocationID.y * localBitCount.y; y < (gl_LocalInvocationID.y + 1) * localBitCount.y; y++)
		{
			for(uint x = gl_LocalInvocationID.x * (localBitCount.x / 32); x < (gl_LocalInvocationID.x + 1) * (localBitCount.x / 32); x++)
			{
				uint idx = bitmapIndex * 256 * 256 * 8 + z * 256 * 8 + y * 8 + x;
				localPositionCount += bitCount(bitmaps[idx]);
			}
		}
	}

	//reserve local invocation space in positions buffer
	uint localOffset = atomicAdd(brickWriteOffset, localPositionCount);
	memoryBarrierShared();

	uint offset = 0;
	//push points to appropriate place in buffer
	for(uint z = gl_LocalInvocationID.z * localBitCount.z; z < (gl_LocalInvocationID.z + 1) * localBitCount.z; z++)
	{
		for(uint y = gl_LocalInvocationID.y * localBitCount.y; y < (gl_LocalInvocationID.y + 1) * localBitCount.y; y++)
		{
			for(uint x = gl_LocalInvocationID.x * (localBitCount.x / 32); x < (gl_LocalInvocationID.x + 1) * (localBitCount.x / 32); x++)
			{
				uint idx = bitmapIndex * 256 * 256 * 8 + z * 256 * 8 + y * 8 + x;
				for(uint bit = 0; bit < 32; bit++)
				{
					if((bitmaps[idx] & (1 << bit)) != 0)
					{
						vec3 position = vec3(x * 32 + bit, y, z) / 256.0f;
						positions[commands[workGroupIndex].first + localOffset + offset++] = packUnorm4x8(position.xyzz);
					}
				}
			}
		}
	}
}